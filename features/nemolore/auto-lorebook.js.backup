/**
 * Hybrid Auto-Lorebook System - Combined AI Generation + NLP Entity Recognition
 * 
 * Features:
 * - AI-powered initial lorebook generation from character data
 * - Real-time entity recognition and discovery from chat messages
 * - Confidence scoring and incremental learning
 * - Automatic entry updates and relationship mapping
 */

// SillyTavern imports - will be loaded dynamically
let world_names, createNewWorldInfo, saveWorldInfo, createWorldInfoEntry, world_info_logic, world_info_position, world_info;
let characters, active_character, callPopup, this_chid, getCurrentChatId, chat, chat_metadata, eventSource, event_types;

/**
 * Initialize SillyTavern imports dynamically
 */
async function initializeSillyTavernImports() {
    try {
        // Load world-info module
        const worldInfoModule = await import('../../../../../world-info.js').catch(() => null);
        if (worldInfoModule) {
            world_names = worldInfoModule.world_names || [];
            createNewWorldInfo = worldInfoModule.createNewWorldInfo;
            saveWorldInfo = worldInfoModule.saveWorldInfo;
            createWorldInfoEntry = worldInfoModule.createWorldInfoEntry;
            world_info_logic = worldInfoModule.world_info_logic || { AND_ANY: 0 };
            world_info_position = worldInfoModule.world_info_position || { before: 0 };
            world_info = worldInfoModule.world_info || {};
        }
        
        // Load script module
        const scriptModule = await import('../../../../../../script.js').catch(() => null);
        if (scriptModule) {
            characters = scriptModule.characters || [];
            active_character = scriptModule.active_character;
            callPopup = scriptModule.callPopup;
            this_chid = scriptModule.this_chid;
            getCurrentChatId = scriptModule.getCurrentChatId || (() => 'default');
            chat = scriptModule.chat || [];
            chat_metadata = scriptModule.chat_metadata || {};
            eventSource = scriptModule.eventSource;
            event_types = scriptModule.event_types || {};
        }
        
        console.log('[NemoLore Auto-Lorebook] SillyTavern imports initialized');
        return true;
    } catch (error) {
        console.warn('[NemoLore Auto-Lorebook] Failed to initialize SillyTavern imports:', error);
        // Provide fallback values
        world_names = [];
        createNewWorldInfo = async (name) => { console.log(`[NemoLore Auto-Lorebook] Fallback createNewWorldInfo called for: ${name}`); return name; };
        saveWorldInfo = async (name) => console.log(`[NemoLore Auto-Lorebook] Fallback saveWorldInfo called for: ${name}`);
        createWorldInfoEntry = (name) => ({ comment: '', content: '', key: [], keysecondary: [] });
        world_info_logic = { AND_ANY: 0 };
        world_info_position = { before: 0 };
        world_info = {};
        characters = [];
        active_character = null;
        callPopup = (content) => Promise.resolve(true);
        this_chid = null;
        getCurrentChatId = () => 'default';
        chat = [];
        chat_metadata = {};
        return false;
    }
}

import { APIManager } from './api-manager.js';

/**
 * Hybrid Auto-Lorebook Manager Class
 * Combines AI generation with real-time NLP entity recognition
 */
export class AutoLorebookManager {
    constructor(settings, state) {
        this.settings = settings;
        this.state = state;
        this.isProcessing = false;
        this.isInitialized = false;
        
        // Entity recognition system (from old sophisticated version)
        this.entityDatabase = new Map();
        this.scanHistory = new Set();
        this.scanInterval = null;
        this.scanTimeout = null;
        
        // Entity recognition patterns (enhanced from original)
        this.entityPatterns = {
            person: /\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b/g,
            place: /\b(?:in|at|from|to|near|by|within)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g,
            organization: /\b(?:the\s+)?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s+(?:Company|Corporation|Inc|LLC|Organization|Guild|Order|Council|Academy|Institute|Temple|Church)\b/g,
            item: /\b(?:the\s+)?([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\s+(?:Sword|Shield|Ring|Amulet|Staff|Blade|Armor|Weapon|Tool|Artifact|Relic|Book|Scroll|Potion|Elixir)\b/g,
            title: /\b(?:Lord|Lady|Sir|Dame|King|Queen|Prince|Princess|Duke|Duchess|Count|Countess|Baron|Baroness|Captain|General|Admiral|Doctor|Professor)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)*)\b/g
        };
        
        // Context analysis patterns (enhanced from original)
        this.contextPatterns = {
            description: /(?:is|was|are|were)\s+(.+?)(?:\.|!|\?|$)/g,
            relationship: /(?:friend|enemy|ally|rival|partner|spouse|child|parent|sibling|mentor|student|master|servant)\s+(?:of|to)\s+([^.!?]+)/g,
            location: /(?:lives|works|stays|resides|dwells|rules|governs)\s+(?:in|at|on|over|within)\s+([^.!?]+)/g,
            attribute: /(?:has|had|possesses|owns|wields|carries|knows|learned|mastered)\s+(.+?)(?:\.|!|\?|$)/g,
            action: /(?:fought|defeated|saved|rescued|destroyed|created|built|founded|discovered)\s+(.+?)(?:\.|!|\?|$)/g,
            emotion: /(?:loves|hates|fears|admires|despises|trusts|distrusts)\s+(.+?)(?:\.|!|\?|$)/g
        };
        
        // Confidence thresholds for different entity types
        this.confidenceThresholds = {
            person: 0.7,
            place: 0.6,
            organization: 0.8,
            item: 0.5,
            title: 0.9
        };
        
        // Common words to filter out
        this.commonWords = new Set([
            'The', 'This', 'That', 'They', 'Them', 'Their', 'There', 'Then', 'Than',
            'When', 'Where', 'What', 'Who', 'Why', 'How', 'Yes', 'No', 'Not',
            'And', 'But', 'Or', 'So', 'If', 'As', 'At', 'By', 'For', 'In',
            'Of', 'On', 'To', 'Up', 'It', 'Is', 'Be', 'Do', 'Go', 'See',
            'All', 'Any', 'Can', 'Had', 'Her', 'Was', 'One', 'Our', 'Out',
            'Day', 'Get', 'Has', 'Him', 'His', 'How', 'Man', 'New', 'Now',
            'Old', 'See', 'Two', 'Way', 'Who', 'Boy', 'Did', 'Its', 'Let',
            'Put', 'Say', 'She', 'Too', 'Use'
        ]);
        
        console.log('[NemoLore Hybrid Auto-Lorebook] Constructor completed with entity recognition system');
    }

    /**
     * Initialize the Hybrid Auto-Lorebook Manager
     */
    async initialize() {
        if (this.isInitialized) return true;
        
        console.log('[NemoLore Hybrid Auto-Lorebook] Initializing...');
        const success = await initializeSillyTavernImports();
        
        if (success) {
            // Set up real-time entity scanning
            this.setupEntityScanning();
            
            // Set up event listeners for message monitoring
            this.setupEventListeners();
            
            // Load existing entity database from metadata
            await this.loadEntityDatabase();
            
            console.log('[NemoLore Hybrid Auto-Lorebook] ✅ Initialized successfully with entity recognition');
        } else {
            console.warn('[NemoLore Hybrid Auto-Lorebook] ⚠️ Initialized with fallbacks');
        }
        
        this.isInitialized = success;
        return success;
    }

    /**
     * Handle intelligent lorebook setup for new chats
     */
    async handleIntelligentLorebookSetup(chatId) {
        if (!this.settings.enabled || this.isProcessing) return;

        // Ensure initialized
        await this.initialize();
        
        console.log(`[NemoLore Auto-Lorebook] Handling setup for chat: ${chatId}`);

        try {
            // Check if auto-lorebook creation is enabled
            if (this.settings.auto_lorebook) {
                await this.createLorebookForChat(chatId);
            }

            // Check if auto-create independent lorebooks is enabled
            if (this.settings.auto_create_lorebook) {
                await this.createIndependentLorebookForCharacter();
            }

            // Check for chat management popup
            if (this.settings.auto_summarize) {
                await this.checkForChatManagement(chatId);
            }

        } catch (error) {
            console.error('[NemoLore Auto-Lorebook] Error in intelligent setup:', error);
        }
    }

    /**
     * Create lorebook for current chat/character
     */
    async createLorebookForChat(chatId) {
        if (!chatId || this.isProcessing) return;

        // Ensure initialized
        await this.initialize();
        
        this.isProcessing = true;
        
        try {
            console.log(`[NemoLore Auto-Lorebook] Creating lorebook for chat: ${chatId}`);
            
            // Get current character info
            const character = characters[this_chid];
            if (!character) {
                console.warn('[NemoLore Auto-Lorebook] No active character found');
                return;
            }

            // Sanitize character name for use in lorebook name
            const sanitizedCharName = character.name.replace(/[^a-zA-Z0-9_-]/g, '_').substring(0, 30);
            const sanitizedChatId = chatId.replace(/[^a-zA-Z0-9_-]/g, '_').substring(0, 20);
            
            // Generate unique lorebook name
            let lorebookName = `${sanitizedCharName}_NemoLore_${sanitizedChatId}`;
            let counter = 1;
            
            // Ensure unique name by adding counter if needed
            while (world_names.includes(lorebookName)) {
                console.log(`[NemoLore Auto-Lorebook] Lorebook exists: ${lorebookName}, trying variant...`);
                lorebookName = `${sanitizedCharName}_NemoLore_${sanitizedChatId}_${counter}`;
                counter++;
                
                // Prevent infinite loop
                if (counter > 10) {
                    console.warn(`[NemoLore Auto-Lorebook] Too many existing lorebooks, using timestamp`);
                    lorebookName = `${sanitizedCharName}_NemoLore_${Date.now()}`;
                    break;
                }
            }

            // Show creation popup
            const shouldCreate = await this.showLorebookCreationPopup(character.name);
            if (!shouldCreate) return;

            // Create the lorebook
            await this.generateAndCreateLorebook(character, lorebookName);
            
            // Set as current chat lorebook
            this.state.currentChatLorebook = lorebookName;
            
            console.log(`[NemoLore Auto-Lorebook] ✅ Successfully created lorebook: ${lorebookName}`);

        } catch (error) {
            console.error('[NemoLore Auto-Lorebook] Error creating lorebook:', error);
        } finally {
            this.isProcessing = false;
        }
    }

    /**
     * Create independent lorebook for character (NemoLore branded)
     */
    async createIndependentLorebookForCharacter() {
        if (this.isProcessing) return;

        try {
            const character = characters[this_chid];
            if (!character) return;

            // Sanitize character name
            const sanitizedCharName = character.name.replace(/[^a-zA-Z0-9_-]/g, '_').substring(0, 30);
            let independentName = `NemoLore_${sanitizedCharName}_World`;
            let counter = 1;
            
            // Ensure unique name
            while (world_names.includes(independentName)) {
                console.log(`[NemoLore Auto-Lorebook] Independent lorebook exists: ${independentName}, trying variant...`);
                independentName = `NemoLore_${sanitizedCharName}_World_${counter}`;
                counter++;
                
                if (counter > 10) {
                    independentName = `NemoLore_${sanitizedCharName}_${Date.now()}`;
                    break;
                }
            }

            const shouldCreate = await this.showIndependentLorebookPopup(character.name);
            if (!shouldCreate) return;

            await this.generateAndCreateLorebook(character, independentName, true);
            
            console.log(`[NemoLore Auto-Lorebook] ✅ Created independent lorebook: ${independentName}`);

        } catch (error) {
            console.error('[NemoLore Auto-Lorebook] Error creating independent lorebook:', error);
        }
    }

    /**
     * Show lorebook creation confirmation popup
     */
    async showLorebookCreationPopup(characterName) {
        const popupHtml = `
            <div style="padding: 20px; max-width: 500px;">
                <h3 style="color: var(--customThemeColor); margin-bottom: 15px;">
                    🧠 NemoLore Automatic Lorebook Creation
                </h3>
                <p>Would you like NemoLore to automatically create a comprehensive lorebook for <strong>${characterName}</strong>?</p>
                <p style="color: var(--SmartThemeQuoteColor); font-size: 0.9em; margin-top: 15px;">
                    <strong>Benefits:</strong><br>
                    • Enhances roleplay with rich world details<br>
                    • Provides character background and relationships<br>
                    • Includes important locations and context<br>
                    • Automatically integrated with this chat
                </p>
                <div style="margin-top: 20px;">
                    <label style="display: flex; align-items: center; margin-bottom: 10px;">
                        <input type="checkbox" id="nemolore-dont-ask-again" style="margin-right: 8px;">
                        Don't ask again (auto-create for future characters)
                    </label>
                </div>
            </div>
        `;

        return new Promise((resolve) => {
            callPopup(popupHtml, 'confirm').then(result => {
                // Check if user selected "don't ask again"
                const dontAskAgain = document.getElementById('nemolore-dont-ask-again')?.checked;
                if (dontAskAgain) {
                    this.settings.auto_lorebook_no_prompt = true;
                    this.saveSettings();
                }
                resolve(result);
            });
        });
    }

    /**
     * Show independent lorebook creation popup
     */
    async showIndependentLorebookPopup(characterName) {
        const popupHtml = `
            <div style="padding: 20px; max-width: 500px;">
                <h3 style="color: var(--customThemeColor); margin-bottom: 15px;">
                    🌟 Independent NemoLore Lorebook
                </h3>
                <p>Create a comprehensive, independent lorebook for <strong>${characterName}</strong>?</p>
                <p style="color: var(--SmartThemeQuoteColor); font-size: 0.9em; margin-top: 15px;">
                    This creates a reusable lorebook that can be used across multiple chats with this character.
                </p>
            </div>
        `;

        return new Promise((resolve) => {
            callPopup(popupHtml, 'confirm').then(resolve);
        });
    }

    /**
     * Generate and create the actual lorebook
     * FIXED: This function has been completely overhauled to use the intended logic.
     * - Uses SillyTavern's main API as a fallback.
     * - Uses a superior prompt inspired by the backup files to request JSON.
     * - Correctly parses JSON and creates entries.
     * - Links the created lorebook to the current chat.
     */
    async generateAndCreateLorebook(character, lorebookName, isIndependent = false) {
        try {
            // Create new world info
            console.log(`[NemoLore Auto-Lorebook] Creating new world info: ${lorebookName}`);
            await createNewWorldInfo(lorebookName);
            
            if (!world_names.includes(lorebookName)) {
                world_names.push(lorebookName);
            }
            
            // Link the lorebook robustly to both chat and character
            try {
                const { METADATA_KEY } = await import('../../../../../world-info.js');
                const scriptModule = await import('../../../../../../script.js');

                // 1. Link to chat metadata
                if (window.chat_metadata && scriptModule.saveMetadata) {
                    chat_metadata[METADATA_KEY] = lorebookName;
                    await scriptModule.saveMetadata();
                    console.log(`[NemoLore Auto-Lorebook] Successfully linked lorebook "${lorebookName}" to the current chat metadata.`);
                }

                // 2. Link to active character data (if the save function exists)
                if (characters[this_chid]) {
                    characters[this_chid].data.world = lorebookName;

                    // Try to save character if the function exists
                    if (scriptModule.saveCharacterDebounced && typeof scriptModule.saveCharacterDebounced === 'function') {
                        await scriptModule.saveCharacterDebounced();
                        console.log(`[NemoLore Auto-Lorebook] Successfully linked lorebook "${lorebookName}" to the active character.`);
                    } else {
                        console.log(`[NemoLore Auto-Lorebook] Linked lorebook to character data (character save function not available).`);
                    }
                }

            } catch (linkError) {
                console.error(`[NemoLore Auto-Lorebook] Failed to link lorebook to chat/character:`, linkError);
            }

            // Build the generation prompt
            const prompt = this.buildInitialGenerationPrompt(character);
            let responseContent;

            // Use custom API if enabled and configured, otherwise fall back to SillyTavern's API
            if (this.settings.enable_async_api && this.settings.async_api_key) {
                console.log('[NemoLore Auto-Lorebook] Using independent API for lorebook generation');
                const apiManager = new APIManager();
                // We need a generic method in APIManager or adapt the existing one.
                // For now, let's assume a generic request can be made.
                const response = await apiManager.makeRequest(
                    this.settings.async_api_provider,
                    this.settings.async_api_key,
                    this.settings.async_api_model,
                    prompt,
                    this.settings.async_api_endpoint
                );
                responseContent = response.content;
            } else {
                console.log('[NemoLore Auto-Lorebook] Using SillyTavern default API for lorebook generation');
                const { generateQuietPrompt } = await import('../../../../../../script.js');
                responseContent = await generateQuietPrompt(prompt, false);
            }

            if (!responseContent) {
                throw new Error("Received an empty response from the AI.");
            }

            // Parse the response
            const lorebookEntries = this.parseGenerationResponse(responseContent);
            if (lorebookEntries.length === 0) {
                console.warn('[NemoLore Auto-Lorebook] No entries were parsed from the AI response. Using fallback.');
                // As a fallback, create a basic entry
                lorebookEntries.push({
                    title: `${character.name} - Background`,
                    keywords: [character.name],
                    description: character.description || 'No detailed background available.'
                });
            }

            // Create entries in the lorebook
            let createdCount = 0;
            console.log(`[NemoLore Auto-Lorebook] Starting to create ${lorebookEntries.length} entries in lorebook "${lorebookName}"`);

            for (const entry of lorebookEntries) {
                // Adapt the parsed entry to the format createLorebookEntry expects
                const formattedEntry = {
                    title: entry.title,
                    keywords: entry.keywords.join(', '),
                    content: entry.description
                };
                console.log(`[NemoLore Auto-Lorebook] Creating entry: "${entry.title}"`);
                const result = await this.createLorebookEntry(lorebookName, formattedEntry);
                if (result) {
                    createdCount++;
                    console.log(`[NemoLore Auto-Lorebook] ✅ Entry created successfully: "${entry.title}"`);
                } else {
                    console.warn(`[NemoLore Auto-Lorebook] ❌ Failed to create entry: "${entry.title}"`);
                }
            }

            console.log(`[NemoLore Auto-Lorebook] Successfully created ${createdCount}/${lorebookEntries.length} entries`);
            console.log(`[NemoLore Auto-Lorebook] Current lorebook has ${world_info[lorebookName]?.entries?.length || 0} entries`);

            // Save the lorebook
            if (world_info[lorebookName]) {
                console.log(`[NemoLore Auto-Lorebook] Attempting to save lorebook "${lorebookName}"...`);
                try {
                    await saveWorldInfo(lorebookName, world_info[lorebookName], true);
                    console.log(`[NemoLore Auto-Lorebook] ✅ Saved lorebook: ${lorebookName}`);
                } catch (saveError) {
                    console.error(`[NemoLore Auto-Lorebook] ❌ Failed to save lorebook:`, saveError);
                }
            } else {
                console.error(`[NemoLore Auto-Lorebook] ❌ Lorebook "${lorebookName}" not found in world_info, cannot save!`);
            }

            this.showSuccessNotification(lorebookName, lorebookEntries.length, isIndependent);

        } catch (error) {
            console.error('[NemoLore Auto-Lorebook] Error generating lorebook:', error);
            // Optionally, show an error notification to the user
        }
    }

    /**
     * Build the prompt for initial lorebook generation.
     * This is the high-quality prompt from the backup file, adapted for this class.
     */
    buildInitialGenerationPrompt(characterData) {
        return `You are an expert worldbuilding assistant. Based on the following character information, create a comprehensive set of lorebook entries that would enhance roleplay sessions.\n\nCharacter Information:\nName: ${characterData.name || 'Unknown'}\nDescription: ${characterData.description || 'No description'}\nPersonality: ${characterData.personality || 'No personality defined'}\nScenario: ${characterData.scenario || 'No scenario defined'}\nFirst Message: ${characterData.first_mes || 'No first message'}\n\nGenerate 8-12 lorebook entries covering:\n1. Important people (friends, family, rivals, mentors)\n2. Significant locations (hometown, workplace, hangouts, districts, regions)\n3. Key items or objects (weapons, heirlooms, technology, artifacts)\n4. Important concepts or lore elements (organizations, customs, phenomena)\n5. Background events or history (conflicts, discoveries, traditions)\n\nFor each entry, provide:\n- A clear, evocative title.\n- Trigger keywords (3-5 relevant keywords including names).\n- A detailed description (2-4 sentences) with rich, specific details.\n\nFormat your response as a single JSON object with a root key "entries", which is an array of entry objects. Each object in the array must have "title", "keywords" (as an array of strings), and "description" fields.\n\nExample:\n{\n  "entries": [\n    {\n      "title": "The Crimson Blade",\n      "keywords": ["Crimson Blade", "magic sword", "heirloom"],\n      "description": "An ancient sword passed down through the character's family. It glows with a faint red light in the presence of danger and is said to contain the spirit of a powerful ancestor."\n    }\n  ]\n}\n\nFocus on elements that would naturally come up in conversation and enhance the roleplay experience with memorable, creative names and rich worldbuilding details.`
    }

    /**
     * Parse the AI's JSON response into structured lorebook entries.
     */
    parseGenerationResponse(response) {
        try {
            // The AI might wrap the JSON in markdown, so we need to extract it.
            const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```|({[\s\S]*})/);
            if (jsonMatch) {
                const jsonString = jsonMatch[1] || jsonMatch[2];
                const parsed = JSON.parse(jsonString);
                if (parsed.entries && Array.isArray(parsed.entries)) {
                    return parsed.entries;
                }
            }
            console.warn('[NemoLore Auto-Lorebook] Could not find valid JSON in the AI response.');
        } catch (error) {
            console.error(`[NemoLore Auto-Lorebook] Error parsing generation response:`, error);
        }
        return [];
    }

    /**
     * Build character information string for AI processing
     */
    buildCharacterInfo(character) {
        // This function is kept for potential future use but the main prompt now includes the character data directly.
        return `\nCharacter Name: ${character.name}\nDescription: ${character.description || 'No description available'}\nPersonality: ${character.personality || 'No personality defined'}\nScenario: ${character.scenario || 'No scenario defined'}\nFirst Message: ${character.first_mes || 'No first message'}\nExample Dialogues: ${character.mes_example || 'No examples available'}\n        `.trim();
    }

    /**
     * Parse AI response into structured lorebook entries
     */
    parseLorebookResponse(response) {
        // This is the old parsing logic, replaced by parseGenerationResponse.
        // Kept here temporarily to avoid breaking other parts of the code if they still use it.
        const entries = [];
        const sections = response.split(/(?=Title:|^Title:)/gm);
        
        for (const section of sections) {
            if (!section.trim() || !section.includes('Title:')) continue;
            
            const lines = section.split('\n');
            let title = '', keywords = '', content = '';
            
            for (const line of lines) {
                if (line.startsWith('Title:')) {
                    title = line.replace('Title:', '').trim();
                } else if (line.startsWith('Keywords:')) {
                    keywords = line.replace('Keywords:', '').trim();
                } else if (line.startsWith('Content:')) {
                    content = lines.slice(lines.indexOf(line) + 1).join('\n').trim();
                    break;
                }
            }
            
            if (title && keywords && content) {
                entries.push({ title, keywords, content });
            }
        }
        
        return entries;
    }

    /**
     * Generate default lorebook entries when API is not available
     */
    generateDefaultLorebookEntries(character) {
        return [
            {
                title: `${character.name} - Background`,
                keywords: character.name,
                content: `${character.name} is a character with the following background: ${character.description || 'No detailed background available.'}`
            },
            {
                title: `${character.name} - Personality`,
                keywords: `${character.name}, personality, traits`,
                content: `${character.name} has the following personality traits: ${character.personality || 'Personality to be developed through roleplay.'}`
            },
            {
                title: `${character.name} - Current Situation`,
                keywords: `${character.name}, scenario, situation`,
                content: `Current scenario: ${character.scenario || 'Open-ended roleplay scenario.'}`
            }
        ];
    }

    /**
     * Create a single lorebook entry
     */
    async createLorebookEntry(lorebookName, entry) {
        try {
            // Check if world-info functions are available
            if (!createWorldInfoEntry || typeof createWorldInfoEntry !== 'function') {
                console.warn('[NemoLore Auto-Lorebook] createWorldInfoEntry not available, creating manual entry');
                // Create entry manually if SillyTavern function not available
                const manualEntry = {
                    uid: Date.now() + Math.random(),
                    comment: entry.title,
                    content: entry.content,
                    key: Array.isArray(entry.keywords) ? entry.keywords : entry.keywords.split(',').map(k => k.trim()),
                    keysecondary: [],
                    selectiveLogic: 0,
                    addMemo: true,
                    order: 100,
                    position: 0,
                    disable: false,
                    constant: false
                };
                
                // Ensure lorebook structure exists
                if (!world_info[lorebookName]) {
                    world_info[lorebookName] = {
                        entries: [],
                        originalData: { entries: {} }
                    };
                }
                
                world_info[lorebookName].entries.push(manualEntry);
                console.log(`[NemoLore Auto-Lorebook] ✅ Created manual entry: ${entry.title}`);
                return manualEntry;
            }
            
            // Ensure the lorebook exists in world_info, create if missing
            if (!world_info[lorebookName]) {
                console.log(`[NemoLore Auto-Lorebook] Lorebook "${lorebookName}" not found in world_info, creating basic structure...`);
                // Create basic lorebook structure if missing
                world_info[lorebookName] = {
                    entries: [],
                    originalData: { 
                        entries: {}
                    }
                };
            }
            
            // Debug the createWorldInfoEntry function
            console.log(`[NemoLore Auto-Lorebook] Calling createWorldInfoEntry with lorebookName: "${lorebookName}"`);
            console.log(`[NemoLore Auto-Lorebook] Available world_info keys:`, Object.keys(world_info));
            console.log(`[NemoLore Auto-Lorebook] createWorldInfoEntry function:`, typeof createWorldInfoEntry);

            // FIXED: createWorldInfoEntry requires TWO parameters: (name, data)
            // It adds the entry to data.entries internally
            const newEntry = createWorldInfoEntry(lorebookName, world_info[lorebookName]);

            console.log(`[NemoLore Auto-Lorebook] createWorldInfoEntry returned:`, newEntry, typeof newEntry);
            
            if (newEntry && typeof newEntry === 'object') {
                // Populate the entry with our data
                newEntry.comment = entry.title;
                newEntry.content = entry.content;
                newEntry.key = Array.isArray(entry.keywords) ? entry.keywords : entry.keywords.split(',').map(k => k.trim());
                newEntry.keysecondary = [];
                newEntry.selectiveLogic = world_info_logic?.AND_ANY || 0;
                newEntry.addMemo = true;
                newEntry.order = 100;
                newEntry.position = world_info_position?.before || 0;
                newEntry.disable = false;
                newEntry.constant = false;

                // NOTE: createWorldInfoEntry already adds the entry to data.entries[uid]
                // We don't need to manually push it

                console.log(`[NemoLore Auto-Lorebook] ✅ Created and added entry: ${entry.title}`);
                return newEntry;
            } else {
                console.warn(`[NemoLore Auto-Lorebook] Failed to create entry object for: ${entry.title}`);
                return null;
            }
            
        } catch (error) {
            console.error(`[NemoLore Auto-Lorebook] Failed to create entry "${entry.title}":`, error);
            return null;
        }
    }

    /**
     * Show success notification
     */
    showSuccessNotification(lorebookName, entryCount, isIndependent) {
        const message = `
            <div style="padding: 15px;">
                <h4 style="color: var(--customThemeColor); margin-bottom: 10px;">
                    ✅ Lorebook Created Successfully!
                </h4>
                <p><strong>Name:</strong> ${lorebookName}</p>
                <p><strong>Entries:</strong> ${entryCount} entries created</p>
                <p><strong>Type:</strong> ${isIndependent ? 'Independent (reusable)' : 'Chat-specific'}</p>
                <p style="color: var(--SmartThemeQuoteColor); font-size: 0.9em; margin-top: 15px;">
                    The lorebook has been automatically activated for this conversation.
                </p>
            </div>
        `;
        
        callPopup(message, 'text');
    }

    /**
     * Check for chat management (summarization) requirements
     * This is now handled by ChatManagementManager
     */
    async checkForChatManagement(chatId) {
        console.log(`[NemoLore Auto-Lorebook] Chat management check delegated to ChatManagementManager for: ${chatId}`);
        // This function is kept for backward compatibility but functionality moved to ChatManagementManager
    }

    /**
     * Save settings
     */
    saveSettings() {
        // This should call the main settings save function
        console.log('[NemoLore Auto-Lorebook] Settings saved');
    }

    // ===== HYBRID SYSTEM: ENTITY RECOGNITION & LEARNING METHODS =====

    /**
     * Set up real-time entity scanning system
     */
    setupEntityScanning() {
        const scanEnabled = this.settings.enable_entity_learning !== false;
        
        if (scanEnabled) {
            // Scan every 30 seconds when entity learning is enabled
            this.scanInterval = setInterval(() => {
                this.scanRecentMessages();
            }, 30000);
            
            console.log('[NemoLore Hybrid Auto-Lorebook] ✅ Real-time entity scanning enabled');
        } else {
            console.log('[NemoLore Hybrid Auto-Lorebook] Entity scanning disabled in settings');
        }
    }

    /**
     * Set up event listeners for message monitoring
     */
    setupEventListeners() {
        if (!eventSource) return;
        
        // Listen for new messages to trigger scanning
        const messageHandler = (data) => {
            if (this.settings.enable_entity_learning !== false) {
                this.scheduleMessageScan(data);
            }
        };
        
        // Handle both sent and received messages
        if (event_types.MESSAGE_SENT) {
            eventSource.on(event_types.MESSAGE_SENT, messageHandler);
        }
        if (event_types.MESSAGE_RECEIVED) {
            eventSource.on(event_types.MESSAGE_RECEIVED, messageHandler);
        }
        
        console.log('[NemoLore Hybrid Auto-Lorebook] ✅ Event listeners configured');
    }

    /**
     * Load existing entity database from chat metadata - FIXED: Uses SillyTavern metadata
     */
    async loadEntityDatabase() {
        try {
            const chatId = getCurrentChatId();
            if (!chatId || !chat_metadata) return;
            
            // CRITICAL FIX: Use SillyTavern's chat_metadata instead of localStorage
            const entityData = chat_metadata.nemolore_entities;
            
            if (entityData) {
                // Migrate from old localStorage format if needed
                if (typeof entityData === 'string') {
                    try {
                        const parsed = JSON.parse(entityData);
                        for (const [key, entity] of Object.entries(parsed)) {
                            this.entityDatabase.set(key, entity);
                        }
                    } catch (parseError) {
                        console.warn('[NemoLore Hybrid Auto-Lorebook] Failed to parse legacy entity data:', parseError);
                    }
                } else if (typeof entityData === 'object') {
                    // New format: direct object
                    for (const [key, entity] of Object.entries(entityData)) {
                        this.entityDatabase.set(key, entity);
                    }
                }
                
                console.log(`[NemoLore Hybrid Auto-Lorebook] Loaded ${this.entityDatabase.size} entities from chat metadata`);
            } else {
                // MIGRATION: Try to load from old localStorage and migrate
                const storageKey = `nemolore_entities_${chatId}`;
                const legacyData = localStorage.getItem(storageKey);
                
                if (legacyData) {
                    console.log('[NemoLore Hybrid Auto-Lorebook] Migrating entities from localStorage to chat metadata');
                    const entityData = JSON.parse(legacyData);
                    for (const [key, entity] of Object.entries(entityData)) {
                        this.entityDatabase.set(key, entity);
                    }
                    
                    // Save to new format and remove old data
                    await this.saveEntityDatabase();
                    localStorage.removeItem(storageKey);
                    console.log(`[NemoLore Hybrid Auto-Lorebook] ✅ Migrated ${this.entityDatabase.size} entities to chat metadata`);
                }
            }
        } catch (error) {
            console.warn('[NemoLore Hybrid Auto-Lorebook] Failed to load entity database:', error);
        }
    }

    /**
     * Save entity database to persistent storage - FIXED: Uses SillyTavern metadata
     */
    async saveEntityDatabase() {
        try {
            const chatId = getCurrentChatId();
            if (!chatId || !chat_metadata) return;
            
            const entityData = {};
            
            for (const [key, entity] of this.entityDatabase) {
                entityData[key] = entity;
            }
            
            // CRITICAL FIX: Store in SillyTavern's chat_metadata instead of localStorage
            chat_metadata.nemolore_entities = entityData;
            
            // Save the metadata using SillyTavern's system
            if (typeof saveMetadata === 'function') {
                await saveMetadata();
                console.log(`[NemoLore Hybrid Auto-Lorebook] ✅ Saved ${this.entityDatabase.size} entities to chat metadata`);
            } else {
                console.warn('[NemoLore Hybrid Auto-Lorebook] saveMetadata function not available');
            }
        } catch (error) {
            console.warn('[NemoLore Hybrid Auto-Lorebook] Failed to save entity database:', error);
        }
    }

    /**
     * Schedule message scanning with debounce
     */
    scheduleMessageScan(messageData) {
        // Debounce scanning to avoid excessive processing
        if (this.scanTimeout) {
            clearTimeout(this.scanTimeout);
        }
        
        this.scanTimeout = setTimeout(() => {
            this.scanMessage(messageData);
        }, 5000); // 5 second delay
    }

    /**
     * Scan recent messages for new entities
     */
    async scanRecentMessages() {
        if (!chat || chat.length === 0) return;
        
        const scanDepth = this.settings.entity_scan_depth || 10;
        const recentMessages = chat.slice(-scanDepth);
        
        let newEntitiesFound = 0;
        
        for (const message of recentMessages) {
            const messageId = message.id || message.send_date || message.timestamp;
            if (messageId && !this.scanHistory.has(messageId)) {
                const foundEntities = await this.scanMessage(message);
                newEntitiesFound += foundEntities;
                this.scanHistory.add(messageId);
            }
        }
        
        if (newEntitiesFound > 0) {
            console.log(`[NemoLore Hybrid Auto-Lorebook] ✅ Discovered ${newEntitiesFound} new entities`);
            await this.saveEntityDatabase();
        }
    }

    /**
     * Scan individual message for entities
     */
    async scanMessage(message) {
        if (!message || !message.mes) return 0;
        
        const content = message.mes;
        const entities = this.extractEntities(content);
        let processedCount = 0;
        
        for (const entity of entities) {
            const processed = await this.processEntity(entity, content, message);
            if (processed) processedCount++;
        }
        
        return processedCount;
    }

    /**
     * Extract entities from text using pattern matching
     */
    extractEntities(text) {
        const entities = [];
        
        for (const [type, pattern] of Object.entries(this.entityPatterns)) {
            let match;
            pattern.lastIndex = 0; // Reset regex state
            
            while ((match = pattern.exec(text)) !== null) {
                const entityName = match[1] || match[0];
                const cleanName = entityName.trim();
                
                if (cleanName.length > 2 && !this.isCommonWord(cleanName)) {
                    const confidence = this.calculateConfidence(cleanName, type, text);
                    
                    if (confidence >= this.confidenceThresholds[type]) {
                        entities.push({
                            name: cleanName,
                            type: type,
                            confidence: confidence,
                            context: this.extractContext(cleanName, text),
                            position: match.index,
                            sourceText: text.substring(Math.max(0, match.index - 50), Math.min(text.length, match.index + cleanName.length + 50))
                        });
                    }
                }
            }
        }
        
        return entities.filter(entity => entity.confidence >= this.confidenceThresholds[entity.type]);
    }

    /**
     * Calculate entity confidence score using multiple factors
     */
    calculateConfidence(entityName, type, text) {
        let confidence = 0.5; // Base confidence
        
        // Capitalization boost
        if (/^[A-Z][a-z]+/.test(entityName)) {
            confidence += 0.2;
        }
        
        // Multiple mentions boost
        const regex = new RegExp(entityName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
        const mentions = (text.match(regex) || []).length;
        if (mentions > 1) {
            confidence += Math.min(0.3, mentions * 0.1);
        }
        
        // Context clues boost
        const contextScore = this.analyzeContextClues(entityName, type, text);
        confidence += contextScore;
        
        // Length and complexity boost
        if (entityName.includes(' ')) {
            confidence += 0.1; // Multi-word entities are often more significant
        }
        
        return Math.min(1.0, confidence);
    }

    /**
     * Analyze context clues around entity for confidence boost
     */
    analyzeContextClues(entityName, type, text) {
        let score = 0;
        const entityRegex = new RegExp(entityName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
        
        let match;
        while ((match = entityRegex.exec(text)) !== null) {
            const start = Math.max(0, match.index - 50);
            const end = Math.min(text.length, match.index + entityName.length + 50);
            const context = text.substring(start, end).toLowerCase();
            
            // Type-specific context clues
            switch (type) {
                case 'person':
                    if (/\b(he|she|they|him|her|them|said|told|asked|spoke|replied)\b/.test(context)) score += 0.2;
                    if (/\b(mr|mrs|ms|dr|sir|lady|lord|master|mistress)\b/.test(context)) score += 0.3;
                    break;
                case 'place':
                    if (/\b(in|at|from|to|near|by|within|outside|inside|through)\b/.test(context)) score += 0.2;
                    if (/\b(city|town|village|kingdom|country|realm|land|region|area|forest|mountain|castle|palace)\b/.test(context)) score += 0.3;
                    break;
                case 'organization':
                    if (/\b(member|leader|joined|founded|part of|belongs to|works for)\b/.test(context)) score += 0.2;
                    if (/\b(guild|order|company|corporation|academy|institute|temple|church|council)\b/.test(context)) score += 0.3;
                    break;
                case 'item':
                    if (/\b(wielded|carried|equipped|owned|found|lost|stolen|forged|enchanted)\b/.test(context)) score += 0.2;
                    if (/\b(weapon|tool|artifact|relic|treasure|magical|ancient|powerful)\b/.test(context)) score += 0.3;
                    break;
                case 'title':
                    if (/\b(rules|governs|leads|commands|serves|appointed|crowned|elected)\b/.test(context)) score += 0.3;
                    break;
            }
        }
        
        return Math.min(0.4, score);
    }

    /**
     * Extract context information for entity
     */
    extractContext(entityName, text) {
        const contexts = [];
        
        for (const [contextType, pattern] of Object.entries(this.contextPatterns)) {
            let match;
            pattern.lastIndex = 0;
            
            while ((match = pattern.exec(text)) !== null) {
                const context = match[0];
                if (context.toLowerCase().includes(entityName.toLowerCase())) {
                    contexts.push({
                        type: contextType,
                        text: (match[1] || context).trim(),
                        confidence: 0.8,
                        fullMatch: context
                    });
                }
            }
        }
        
        return contexts;
    }

    /**
     * Check if word is too common to be a significant entity
     */
    isCommonWord(word) {
        return this.commonWords.has(word) || word.length < 3;
    }

    /**
     * Process discovered entity - create or update lorebook entry
     */
    async processEntity(entity, sourceText, sourceMessage) {
        try {
            // Check if entity already exists in our database
            const existingEntity = this.entityDatabase.get(entity.name.toLowerCase());
            
            if (existingEntity) {
                // Update existing entity
                return await this.updateExistingEntity(existingEntity, entity, sourceText);
            } else {
                // Check if confidence is high enough to create new entry
                if (entity.confidence >= 0.8) {
                    return await this.createEntityEntry(entity, sourceText, sourceMessage);
                }
            }
            
            return false;
        } catch (error) {
            console.error('[NemoLore Hybrid Auto-Lorebook] Error processing entity:', error);
            return false;
        }
    }

    /**
     * Create new lorebook entry for discovered entity
     */
    async createEntityEntry(entity, sourceText, sourceMessage) {
        try {
            // Get current lorebook name or create one
            const lorebookName = this.state.currentChatLorebook || await this.getCurrentLorebookName();
            if (!lorebookName) return false;
            
            // Check if entry limit reached
            const maxEntries = this.settings.max_auto_entries || 100;
            if (this.entityDatabase.size >= maxEntries) {
                console.log('[NemoLore Hybrid Auto-Lorebook] Maximum entity entries reached');
                return false;
            }
            
            // Generate entry content using AI or template
            const entryContent = await this.generateEntityEntryContent(entity, sourceText);
            
            const lorebookEntry = {
                title: `${entity.name} - ${entity.type}`,
                keywords: this.generateEntityKeywords(entity),
                content: entryContent
            };
            
            // Create the actual lorebook entry
            const success = await this.createLorebookEntry(lorebookName, lorebookEntry);
            
            if (success) {
                // Store in our entity database
                this.entityDatabase.set(entity.name.toLowerCase(), {
                    name: entity.name,
                    type: entity.type,
                    confidence: entity.confidence,
                    contexts: entity.context || [],
                    mentions: 1,
                    created: Date.now(),
                    lastSeen: Date.now(),
                    lorebookEntry: lorebookEntry.title,
                    sourceMessage: sourceMessage?.id || null
                });
                
                console.log(`[NemoLore Hybrid Auto-Lorebook] ✅ Created entity entry: ${entity.name} (${entity.type})`);
                return true;
            }
            
            return false;
        } catch (error) {
            console.error('[NemoLore Hybrid Auto-Lorebook] Error creating entity entry:', error);
            return false;
        }
    }

    /**
     * Update existing entity with new information
     */
    async updateExistingEntity(existingEntity, newEntity, sourceText) {
        try {
            // Increment mentions
            existingEntity.mentions = (existingEntity.mentions || 0) + 1;
            
            // Update confidence (weighted average)
            const totalMentions = existingEntity.mentions;
            existingEntity.confidence = ((existingEntity.confidence * (totalMentions - 1)) + newEntity.confidence) / totalMentions;
            
            // Add new context information
            if (newEntity.context && newEntity.context.length > 0) {
                existingEntity.contexts = existingEntity.contexts || [];
                for (const context of newEntity.context) {
                    if (!existingEntity.contexts.find(c => c.text === context.text)) {
                        existingEntity.contexts.push(context);
                    }
                }
                
                // Limit contexts to prevent bloat
                if (existingEntity.contexts.length > 10) {
                    existingEntity.contexts = existingEntity.contexts.slice(-10);
                }
            }
            
            existingEntity.lastSeen = Date.now();
            
            // If confidence increased significantly, consider updating the lorebook entry
            if (newEntity.confidence > existingEntity.confidence + 0.1) {
                await this.updateEntityLorebookEntry(existingEntity, sourceText);
            }
            
            console.log(`[NemoLore Hybrid Auto-Lorebook] ✅ Updated entity: ${existingEntity.name} (mentions: ${existingEntity.mentions})`);
            return true;
        } catch (error) {
            console.error('[NemoLore Hybrid Auto-Lorebook] Error updating entity:', error);
            return false;
        }
    }

    /**
     * Generate content for entity entry using AI or fallback template
     */
    async generateEntityEntryContent(entity, sourceText) {
        let content = `${entity.name} is a ${entity.type}`;
        
        // Add context information
        if (entity.context && entity.context.length > 0) {
            const contextTexts = entity.context
                .filter(ctx => ctx.text && ctx.text.length > 3)
                .map(ctx => ctx.text)
                .slice(0, 3); // Limit to 3 most relevant contexts
                
            if (contextTexts.length > 0) {
                content += `. ${contextTexts.join('. ')}`;
            }
        }
        
        // Add discovery note
        content += ` (Discovered from roleplay conversation with ${entity.confidence.toFixed(2)} confidence)`;
        
        // Limit content length
        const maxLength = this.settings.entity_entry_length || 200;
        if (content.length > maxLength) {
            content = content.substring(0, maxLength - 3) + '...';
        }
        
        return content;
    }

    /**
     * Generate keywords for entity
     */
    generateEntityKeywords(entity) {
        const keywords = [entity.name];
        
        // Add variations
        if (entity.name.includes(' ')) {
            // Add first name only for persons
            if (entity.type === 'person') {
                keywords.push(entity.name.split(' ')[0]);
            }
            // Add last word for places/organizations
            keywords.push(entity.name.split(' ').slice(-1)[0]);
        }
        
        // Add lowercase version
        keywords.push(entity.name.toLowerCase());
        
        return keywords.filter((keyword, index, arr) => arr.indexOf(keyword) === index); // Remove duplicates
    }

    /**
     * Update existing lorebook entry with new information
     */
    async updateEntityLorebookEntry(entity, sourceText) {
        // This would update the actual lorebook entry content
        // Implementation depends on how we want to handle updates
        console.log(`[NemoLore Hybrid Auto-Lorebook] Considering update for: ${entity.name}`);
    }

    /**
     * Get current lorebook name or create one if needed
     */
    async getCurrentLorebookName() {
        if (this.state.currentChatLorebook && world_names.includes(this.state.currentChatLorebook)) {
            return this.state.currentChatLorebook;
        }
        
        // Try to create a default lorebook for entity learning
        const character = characters[this_chid];
        if (!character) return null;
        
        const chatId = getCurrentChatId();
        const entityLorebookName = `${character.name}_Entities_${chatId}`;
        
        try {
            await createNewWorldInfo(entityLorebookName);
            this.state.currentChatLorebook = entityLorebookName;
            return entityLorebookName;
        } catch (error) {
            console.error('[NemoLore Hybrid Auto-Lorebook] Failed to create entity lorebook:', error);
            return null;
        }
    }

    /**
     * Get statistics about discovered entities
     */
    getEntityStatistics() {
        const entities = Array.from(this.entityDatabase.values());
        
        const stats = {
            totalEntities: entities.length,
            byType: {},
            averageConfidence: 0,
            totalMentions: 0,
            recentlyActive: 0
        };
        
        if (entities.length > 0) {
            // Calculate type distribution
            for (const entity of entities) {
                stats.byType[entity.type] = (stats.byType[entity.type] || 0) + 1;
                stats.totalMentions += entity.mentions || 1;
                stats.averageConfidence += entity.confidence || 0;
                
                // Check if seen in last 24 hours
                if (entity.lastSeen && (Date.now() - entity.lastSeen) < 86400000) {
                    stats.recentlyActive++;
                }
            }
            
            stats.averageConfidence = stats.averageConfidence / entities.length;
        }
        
        return stats;
    }

    /**
     * Cleanup and shutdown entity recognition
     */
    async shutdown() {
        console.log('[NemoLore Hybrid Auto-Lorebook] Shutting down entity recognition...');
        
        // Clear intervals and timeouts
        if (this.scanInterval) {
            clearInterval(this.scanInterval);
            this.scanInterval = null;
        }
        
        if (this.scanTimeout) {
            clearTimeout(this.scanTimeout);
            this.scanTimeout = null;
        }
        
        // Save final entity database state
        await this.saveEntityDatabase();
        
        this.isInitialized = false;
        console.log('[NemoLore Hybrid Auto-Lorebook] ✅ Shutdown completed');
    }

    /**
     * Finds or creates the "Core Memories" lorebook entry and appends new content.
     */
    async addCoreMemoryToLorebook(summaryData) {
        const CORE_MEMORY_TITLE = 'Core Memories';
        const CORE_MEMORY_KEYWORDS = ['core_memories', 'pivotal_events', 'key_moments'];

        // Ensure we have a lorebook to work with
        const lorebookName = this.state.currentChatLorebook || await this.getCurrentLorebookName();
        if (!lorebookName) {
            console.error('[NemoLore] Cannot add core memory: No active lorebook.');
            return;
        }

        // Find the existing "Core Memories" entry
        let coreMemoryEntry = null;
        if (world_info[lorebookName] && world_info[lorebookName].entries) {
            coreMemoryEntry = world_info[lorebookName].entries.find(
                entry => entry.comment === CORE_MEMORY_TITLE
            );
        }

        const newMemoryContent = `\n- ${new Date().toLocaleString()}: ${summaryData.text}`;

        if (coreMemoryEntry) {
            // Append to the existing entry
            coreMemoryEntry.content += newMemoryContent;
            console.log(`[NemoLore] Appended core memory to existing entry in ${lorebookName}.`);
        } else {
            // Create a new entry if it doesn't exist
            console.log(`[NemoLore] Creating new "Core Memories" entry in ${lorebookName}.`);
            const entryData = {
                title: CORE_MEMORY_TITLE,
                keywords: CORE_MEMORY_KEYWORDS.join(', '),
                content: `A collection of the most significant moments in the story.${newMemoryContent}`
            };
            await this.createLorebookEntry(lorebookName, entryData);
        }

        // Save the changes to the lorebook file
        await saveWorldInfo(lorebookName, world_info[lorebookName], true);
    }
}

console.log('[NemoLore Hybrid Auto-Lorebook] Module loaded - AI Generation + Real-time Entity Learning ready');